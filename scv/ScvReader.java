package de.toem.impulse.extension.eda.transaction.scv;

import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

import de.toem.impulse.ImpulseBase;
import de.toem.impulse.cells.record.IRecord;
import de.toem.impulse.cells.record.RecordScope;
import de.toem.impulse.extension.eda.transaction.i18n.I18n;
import de.toem.impulse.samples.ISample;
import de.toem.impulse.samples.ISamples;
import de.toem.impulse.samples.IStructSamplesWriter;
import de.toem.impulse.samples.domain.IDomainBase;
import de.toem.impulse.samples.domain.TimeBase;
import de.toem.impulse.samples.raw.StructMember;
import de.toem.impulse.serializer.AbstractSingleDomainRecordReader;
import de.toem.impulse.serializer.IParsingRecordReader;
import de.toem.toolkits.core.Utils;
import de.toem.toolkits.pattern.bundles.Bundles;
import de.toem.toolkits.pattern.element.ICell;
import de.toem.toolkits.pattern.element.serializer.ISerializerDescriptor;
import de.toem.toolkits.pattern.element.serializer.JavaSerializerPreference;
import de.toem.toolkits.pattern.element.serializer.SingletonSerializerPreference.DefaultSerializerConfiguration;
import de.toem.toolkits.pattern.filter.FilterExpression;
import de.toem.toolkits.pattern.ide.ConfiguredConsoleStream;
import de.toem.toolkits.pattern.properties.IPropertyModel;
import de.toem.toolkits.pattern.properties.PropertyModel;
import de.toem.toolkits.pattern.registry.IRegistryObject;
import de.toem.toolkits.pattern.registry.RegistryAnnotation;
import de.toem.toolkits.pattern.threading.IProgress;
import de.toem.toolkits.utils.collections.SimpleVector;
import de.toem.toolkits.utils.serializer.ParseException;
import de.toem.toolkits.utils.serializer.text.FastLineParser;
import de.toem.toolkits.utils.text.MultilineText;

/**
 * SCV (SystemC Verification) Transaction Reader implementation for impulse.
 *
 * This reader parses SCV transaction log files (typically .scv, .txlog) and converts them into impulse record structures. The SCV format is a
 * text-based format that stores transaction-based data, typically generated by SystemC simulations or EDA tools.
 *
 * Key features implemented by this reader: - Parsing of SCV text log format with support for streams, generators, events, and attributes -
 * Hierarchical signal creation from stream definitions - Configurable path separator for hierarchical signal names - Transaction event processing
 * with timestamp synchronization and attribute extraction - Filtering support for streams, generators, and attributes (include/exclude) - Attribute
 * layering and grouping for visualization - Backlog/history management for efficient memory usage - Relation tracking between transactions - Console
 * logging and progress reporting
 *
 * The hierarchical signal structure is created based on stream names, using a configurable path separator (default: ".") to determine the hierarchy.
 * Each component of the path becomes a scope in the record structure, with the final component being the signal name.
 *
 * Implementation Notes: - Uses TimeBase.ps (picoseconds) as the base time unit for all signals - Preserves original stream hierarchies in the impulse
 * record structure - Supports attribute filtering and generator/stream filtering via property model - Handles both begin and end attributes for
 * transactions, as well as record attributes - Supports relation parsing and attachment between events - Automatically detects files with .scv, .SCV,
 * or .txlog extension
 *
 * Copyright (c) 2013-2025 Thomas Haber All rights reserved.
 *
 * @see de.toem.impulse.serializer.IParsingRecordReader
 */
@RegistryAnnotation(annotation = ScvReader.Annotation.class)
public class ScvReader extends AbstractSingleDomainRecordReader {

    /**
     * Annotation metadata for the SCV reader.
     */
    public static class Annotation extends AbstractSingleDomainRecordReader.Annotation {
        public static final String id = "de.toem.impulse.reader.scv";
        public static final String label = I18n.Serializer_ScvReader;
        public static final String description = I18n.Serializer_ScvReader_Description;
        public static final String helpURL = I18n.Serializer_ScvReader_HelpURL;
        public static final String defaultNamePattern = "\\.scv$,\\.SCV$,\\.txlog$";
        public static final String formatType = "scv";
        public static final String certificate = "EML/98HQHwifAPO8DAeUASUrBr5WzH78\nVhODxCEfY7ExnE2ylazpEwuuq2EVmdJT\ngxpkFOEmAqkU6uVBl8aJVVrYkwPSzJaF\nHkkoJ30OyOus32cE7YnIMRETtAegBG12\npEoaVokZbyfN8n+x6wMQ4CcGcxWOA9LY\nuIhjJH3o8OxpgsHjUp4vFR3QGmwOna0d\nETtv1pK8dv2TUx6u5nwdrPvIGJM5Dsvg\neH8G9ouw/NMPYSzkAl2CzS+hvE/6Q5MG\nn13+LqS8MYxKydQhO6Gawj70sUmND8k3\n6Mawp4TdDwll1WMLcH16YCvbFRcf7+fJ\npp1qHl4ATvuSLaGgyqX30RlzCix95KBj\n";
    }

    // ========================================================================================================================
    // Constants and configuration
    // ========================================================================================================================

    // Default maximum number of attributes per generator
    private static final int DEFAULT_ATTRIBUTES = 64;
    // Default backlog size for event buffering
    private static final int DEFAULT_BACKLOG = 10;
    // Default history size for event vector
    private static final int DEFAULT_HISTORY = 1000000;

    // ========================================================================================================================
    // Parsing state and configuration
    // ========================================================================================================================

    // The line parser for SCV files
    private ScvLineParser lineParser;

    // Vector of streams (indexed by stream ID)
    private SimpleVector<Stream> streams;
    // Vector of generators (indexed by generator ID)
    private SimpleVector<Generator> generators;
    // Vector of events (circular buffer for event IDs)
    private EventVector events;
    // The current event being processed
    private Event currentEvent = null;
    // Special event instance representing an excluded event
    private final Event EXLUDED = new Event(-1);

    // Charset for input (not currently used)
    private Charset charset;
    // Whether to resolve hierarchy in signal names
    private boolean hierarchyResolution;
    // Backlog size for event buffering
    private int backlog;
    // History size for event vector
    private int history;
    // Whether to exclude all relations
    private boolean excludeAllRelation;
    // Whether to exclude all record attributes
    private boolean excludeAllRecordAttributes;
    // Maximum number of attributes per generator
    private int maxAttributes;
    // Include filter for streams
    private List<FilterExpression> includeStreams;
    // Exclude filter for streams
    private List<FilterExpression> excludeStreams;
    // Include filter for generators
    private List<FilterExpression> includeGenerators;
    // Exclude filter for generators
    private List<FilterExpression> excludeGenerators;
    // Include filter for attributes
    private List<FilterExpression> includeAttributes;
    // Exclude filter for attributes
    private List<FilterExpression> excludeAttributes;
    // Filter for generator layers
    private List<FilterExpression> generatorLayers;
    // Filter for attributes to be treated as text
    private List<FilterExpression> useText;
    // Start time for parsing
    private long start;
    // End time for parsing
    private long end;

    // ========================================================================================================================
    // Token constants for SCV parsing
    // ========================================================================================================================

    // Token hash for transaction record attribute
    static final int TOKEN_TX_RECORD_ATTRIBUTE = 349577960;
    // Token hash for transaction begin
    static final int TOKEN_TX_BEGIN = 434726447;
    // Token hash for transaction end
    static final int TOKEN_TX_END = 27271137;
    // Token hash for transaction relation
    static final int TOKEN_TX_RELATION = -434579786;
    // Token hash for stream definition
    static final int TOKEN_SCV_TR_STREAM = 648387879;
    // Token hash for generator definition
    static final int TOKEN_SCV_TR_GENERATOR = -2036918324;
    // Token hash for begin attribute
    static final int TOKEN_BEGIN_ATTRIBUTE = 619904101;
    // Token hash for end attribute
    static final int TOKEN_END_ATTRIBUTE = 457368023;
    // Token hash for attribute value
    static final int TOKEN_A = 128;
    // Token hash for end of generator
    static final int TOKEN_SCV_END_GENERATOR = 72;

    // ========================================================================================================================
    // Constructors
    // ========================================================================================================================

    /**
     * Default constructor for the SCV reader.
     */
    public ScvReader() {
        super();
    }

    /**
     * Fully parameterized constructor for the SCV reader.
     *
     * @param descriptor
     *            The serializer descriptor providing contextual information
     * @param contentName
     *            The name of the content being processed
     * @param contentType
     *            The MIME type or other format descriptor of the content
     * @param cellType
     *            The type of cell that will be produced
     * @param configuration
     *            Configuration name for specialized settings
     * @param properties
     *            Additional properties as key-value pairs
     * @param in
     *            The input stream containing the data to be read
     */
    public ScvReader(ISerializerDescriptor descriptor, String contentName, String contentType, String cellType, String configuration,
            String[][] properties, InputStream in) {
        super(descriptor, configuration, properties, getPropertyModel(descriptor, null), in);
    }

    // ========================================================================================================================
    // Support Interface
    // ========================================================================================================================

    /**
     * Determines if this reader supports the specified functionality request.
     *
     * @param request
     *            An Integer identifying the functionality being queried
     * @param context
     *            Additional context for the request
     * @return true if the reader supports the requested functionality, false otherwise
     */
    public static boolean supports(Object request, Object context) {
        int ir = request instanceof Integer ? ((Integer) request).intValue() : -1;
        if (SUPPORT_CONFIGURATION == ir && DefaultSerializerConfiguration.TYPE.equals(context))
            return true;
        return ir == (ir & SUPPORT_PROPERTIES | SUPPORT_SOURCE);
    }

    /**
     * Creates a Java serializer preference for this reader.
     * 
     * @return The Java serializer preference cell.
     */
    public static ICell createJavaPreference() {
        try {
            JavaSerializerPreference p = new JavaSerializerPreference();
            p.setName(Annotation.label);
            p.description = Annotation.description;
            p.helpUrl = Annotation.helpURL;
            p.namePattern = Annotation.defaultNamePattern;
            p.formatType = Annotation.formatType;
            p.certificate = Annotation.certificate;
            p.impl = MultilineText.toXml(Bundles.getBundleSourceEntryAsString(ScvReader.class));
            p.javaBundle = Utils.commarize(ImpulseBase.BUNDLE_ID,Bundles.getBundleId(ScvReader.class));   
            p.cellType = IRecord.Record.TYPE;
            return p;
        } catch (Throwable e) {
        }
        return null;
    }

    // ========================================================================================================================
    // Property Model
    // ========================================================================================================================

    /**
     * Creates and returns the property model for configuring this reader.
     *
     * @param object
     *            The serializer descriptor, used to provide context
     * @param context
     *            Additional context information
     * @return The property model containing all configurable properties for this reader
     */
    static public IPropertyModel getPropertyModel(ISerializerDescriptor object, Object context) {
        boolean notPref = context != IRegistryObject.Preference.class;
        PropertyModel model = IParsingRecordReader.getPropertyModel(PROP_INCLUDE | PROP_HIERARCHY | (notPref ? (PROP_RANGE | PROP_TRANSFORM) : 0))
                .add("backlog", DEFAULT_BACKLOG, null, null, null, "Backlog", null, null)
                .add("history", DEFAULT_HISTORY, null, null, null, "History", null, null)
                .add("excludeAllRelation", true, null, "Exclude all relations", null, null)
                .add("excludeAllRecordAttributes", false, null, "Exclude all record attributes", null, null)
                .add("maxAttributes", DEFAULT_ATTRIBUTES, null, null, null, "Max number of attributes", null, null)
                .add("includeGenerators", "", null, null, "Include Generators", null, null)
                .add("excludeGenerators", "", null, null, "Exclude Generators", null, null)
                .add("includeAttributes", "", null, null, "Include Attributes", null, null)
                .add("excludeAttributes", "", null, null, "Exclude Attributes", null, null)
                .add("generatorLayers", "", null, null, "Layer By Generator", null, null).add("useText", "", null, null, "Use Text", null, null)
                .add(ConfiguredConsoleStream.getPropertyModel());
        model.setDefaultVal("hierarchy", ".");
        return model;
    }

    // ========================================================================================================================
    // Applicable
    // ========================================================================================================================

    /**
     * Determines if this reader can process the specified input based on the file name and content type.
     * 
     * @param name
     *            The name of the file or content
     * @param contentType
     *            The MIME type or other format descriptor of the content
     * @return APPLICABLE if this reader can process the input, NOT_APPLICABLE otherwise
     */
    @Override
    protected int isApplicable(String name, String contentType) {
        return 32;
    }

    /**
     * Determines if this reader can process the specified input based on the file buffer.
     * 
     * @param buffer
     *            The file buffer
     * @return APPLICABLE if this reader can process the input, NOT_APPLICABLE otherwise
     */
    @Override
    protected int isApplicable(byte[] buffer) {
        if (isGzipStream(buffer) || new String(buffer).contains("scv_tr_stream"))
            return APPLICABLE;
        return NOT_APPLICABLE;
    }

    // ========================================================================================================================
    // Parser
    // ========================================================================================================================

    /**
     * Parses the input stream and creates a record structure. This implementation follows the SCV format specification.
     *
     * @param progress
     *            Interface for reporting progress and checking for cancellation
     * @param in
     *            The input stream containing the data to be read
     * @throws ParseException
     *             If an error occurs during parsing
     */
    @Override
    protected void parse(IProgress progress, InputStream in) throws ParseException {

        // base
        TimeBase timeBase = TimeBase.ps;

        // parameter

        // charset
        // this.charset = Charset.forName(properties.get("charset"));

        // geometry
        this.maxAttributes = Utils.parseInt(getProperty("maxAttributes"), DEFAULT_ATTRIBUTES);
        this.backlog = Utils.parseInt(getProperty("backlog"), DEFAULT_BACKLOG);
        this.history = Utils.parseInt(getProperty("history"), DEFAULT_HISTORY);

        // hierarchy
        this.hierarchyResolution = Boolean.TRUE == getTypedProperty("hierarchy");

        // exclude/include
        this.excludeAllRelation = Boolean.TRUE == getTypedProperty("excludeAllRelation");
        this.excludeAllRecordAttributes = Boolean.TRUE == getTypedProperty("excludeAllRecordAttributes");
        this.includeStreams = FilterExpression.createList(getProperty("include"), FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);
        this.excludeStreams = FilterExpression.createList(getProperty("exclude"), FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);
        this.includeGenerators = FilterExpression.createList(getProperty("includeGenerators"),
                FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);
        this.excludeGenerators = FilterExpression.createList(getProperty("excludeGenerators"),
                FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);
        this.includeAttributes = FilterExpression.createList(getProperty("includeAttributes"),
                FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);
        this.excludeAttributes = FilterExpression.createList(getProperty("excludeAttributes"),
                FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);

        // generator layers
        this.generatorLayers = FilterExpression.createList(getProperty("generatorLayers"),
                FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);

        // use text for attributes
        this.useText = FilterExpression.createList(getProperty("useText"), FilterExpression.TYPE_REGULAR | FilterExpression.TYPE_TEXT);

        // start / end
        this.start = timeBase.parseMultiple(getProperty("start"), IDomainBase.PARSE_BIG, Long.MIN_VALUE).longValue();
        this.end = timeBase.parseMultiple(getProperty("end"), IDomainBase.PARSE_BIG, Long.MAX_VALUE).longValue();

        // model
        streams = new SimpleVector<Stream>(1024);
        generators = new SimpleVector<Generator>(1024);
        events = new EventVector(history);

        // lines
        int linesProcessed = 0;
        boolean isStarted = false;
        boolean stop = false;

        try {
            final ScvLineParser line = this.lineParser = new ScvLineParser(decompressStream(in)/* ,charset */);

            // init record
            initRecord("Transaction File", timeBase);
            changed(CHANGED_RECORD);

            while (line.readLine() && !stop && (progress == null || !progress.isCanceled())) {

                // processed
                linesProcessed++;
                if (progress != null && (linesProcessed % 1000) == 0) {
                    flushAndSetProgress(progress);
                    changed(CHANGED_CURRENT);
                }

                // extract token and dispatch handling
                switch (line.extractTokenHash()) {
                case TOKEN_SCV_TR_STREAM: {
                    line.pass('(');
                    line.pass("ID".toCharArray());
                    int id = (int) line.extractInt();
                    line.pass(',');
                    line.pass("name".toCharArray());
                    String name = line.extractStringifiedText();
                    line.pass(',');
                    line.pass("kind".toCharArray());
                    String kind = line.extractStringifiedText();
                    line.pass(')');
                    new Stream(id, name, kind);
                }
                    break;
                case TOKEN_SCV_TR_GENERATOR: {
                    line.pass('(');
                    line.pass("ID".toCharArray());
                    int id = (int) line.extractInt();
                    line.pass(',');
                    line.pass("name".toCharArray());
                    String name = line.extractStringifiedText();
                    line.pass(',');
                    line.pass("scv_tr_stream".toCharArray());
                    int sid = (int) line.extractInt();
                    line.pass(',');
                    if (!streams.has(sid))
                        throw new ParseException(0, "Invalid stream id " + sid + " for generator " + id);
                    Generator generator = new Generator(id, name, sid);

                    List<StructMember> begin = new ArrayList<StructMember>();
                    List<StructMember> end = new ArrayList<StructMember>();
                    while (line.readLine() && !stop && (progress == null || !progress.isCanceled())) {
                        final int token = line.extractTokenHash();
                        if (token == TOKEN_BEGIN_ATTRIBUTE) {
                            line.pass('(');
                            line.pass("ID".toCharArray());
                            int aid = (int) line.extractInt();
                            line.pass(',');
                            line.pass("name".toCharArray());
                            String aname = line.extractStringifiedToken();
                            line.pass(',');
                            line.pass("type".toCharArray());
                            String type = line.extractStringifiedToken();
                            line.pass(')');
                            begin.add(new StructMember(-1, null, aname, null, null, null, structType(aname, type), -1, format(aname, type), null));
                        } else if (token == TOKEN_END_ATTRIBUTE) {
                            line.pass('(');
                            line.pass("ID".toCharArray());
                            int aid = (int) line.extractInt();
                            line.pass(',');
                            line.pass("name".toCharArray());
                            String aname = line.extractStringifiedToken();
                            line.pass(',');
                            line.pass("type".toCharArray());
                            String type = line.extractStringifiedToken();
                            line.pass(')');
                            end.add(new StructMember(-1, null, aname, null, null, null, structType(aname, type), -1, format(aname, type), null));
                        } else if (token == TOKEN_SCV_END_GENERATOR) {
                            generator.init(begin, end);
                            break;
                        }
                    }
                }
                    break;
                case TOKEN_TX_BEGIN: {
                    int id = (int) line.extractInt();
                    int gid = (int) line.extractInt();
                    Generator generator = generators.get(gid);
                    if (generator == null)
                        throw new ParseException(0, "Invalid generator id " + gid + " for tx_begin " + id);
                    if (generator.isExcluded()) {
                        events.exclude(id);
                        currentEvent = EXLUDED;
                        break;
                    }
                    long t = line.extractLong();
                    TimeBase base = line.extractUnit();
                    t = base.convertTo(timeBase, t);
                    if (!isStarted) {
                        if (t < start) {
                            events.exclude(id);
                            currentEvent = EXLUDED;
                            break;
                        } else
                            isStarted = true;
                    } else if (t > end) {
                        stop = true;
                        break;
                    }
                    // create new Event and register in event vector for lookup by id
                    Event event = generator.newEvent(id, t);
                    events.set(currentEvent = event);
                }
                    break;
                case TOKEN_TX_END: {
                    int id = (int) line.extractInt();
                    int gid = (int) line.extractInt();
                    Generator generator = generators.get(gid);
                    if (generator == null)
                        throw new ParseException(0, "Invalid generator id " + gid + " for tx_end " + id);
                    if (generator.isExcluded()) {
                        currentEvent = EXLUDED;
                        break;
                    }
                    long t = line.extractLong();
                    TimeBase base = line.extractUnit();
                    t = base.convertTo(timeBase, t);
                    if (!isStarted) {
                        if (t < start) {
                            events.exclude(id);
                            currentEvent = EXLUDED;
                            break;
                        } else
                            isStarted = true;
                    } else if (t > end) {
                        stop = true;
                    }
                    // try to find corresponding begin event (may be current or in buffer)
                    Event event = currentEvent != null && currentEvent.id == id ? currentEvent : events.get(id);
                    if (event == null)
                        throw new ParseException(0, "Can not find begin event :" + id + "," + gid + "," + t);
                    else if (event == EXLUDED)
                        break;
                    else {
                        // if end matches begin exactly convert to single, otherwise create final event
                        if (!event.isDisposed() && event.generator == generator && t == event.time) {
                            event.toSingle(); // convert initial to single sample
                        } else {
                            event = generator.newEvent(event, t); // create matching final event
                        }
                        currentEvent = event;
                    }
                    // write events for this stream while keeping backlog entries
                    generator.stream.write(backlog);
                }
                    break;
                case TOKEN_A: {
                    if (currentEvent == EXLUDED || !isStarted)
                        break;
                    else if (currentEvent == null)
                        throw new ParseException(0, "Can not find current event");
                    int idx = currentEvent.attributePos;
                    if (idx < 0)
                        throw new ParseException(0, "Invalid attribute :" + currentEvent.id);
                    final Object value = line.extractValue(currentEvent.generator.attributes[idx]);
                    if (value == null)
                        throw new ParseException(0, "Invalid attribute value:" + currentEvent.id + "," + line);
                    currentEvent.attributes[idx] = value;
                }
                    break;
                case TOKEN_TX_RECORD_ATTRIBUTE: {
                    if (!excludeAllRecordAttributes || !isStarted) {
                        int id = (int) line.extractInt();
                        Event event = currentEvent != null && currentEvent.id == id ? currentEvent : events.get(id);
                        if (event == EXLUDED)
                            break;
                        else if (event == null)
                            throw new ParseException(0, "Can not find event for record attribute:" + id);
                        else if (event.isDisposed())
                            throw new ParseException(0,
                                    "Can not find event for record attribute (allready written):" + id + " Please try extending backlog.");

                        final ScvLineParser.Pair nameType = line.extractNameTypePair();
                        int idx = event.generator.getAttributeIndex(nameType);
                        if (idx < 0)
                            throw new ParseException(0, "Invalid record attribute :" + id + "," + nameType.o1 + "," + nameType.o2);
                        else if (idx == 0) // excluded
                            continue;
                        line.pass('=');
                        final Object value = line.extractValue(event.generator.attributes[idx]);
                        if (value == null)
                            throw new ParseException(0, "Invalid record attribute value:" + id + "," + line);
                        event.attributes[idx] = value;
                    }
                }
                    break;
                case TOKEN_TX_RELATION: {
                    if (!excludeAllRelation || !isStarted) {
                        String label = line.extractStringifiedToken();
                        int id = (int) line.extractInt();
                        Event event = currentEvent != null && currentEvent.id == id ? currentEvent : events.get(id);
                        if (event == EXLUDED)
                            break;
                        else if (event == null)
                            throw new ParseException(0, "Can not find source event for relation:" + id);
                        else if (event.isDisposed())
                            throw new ParseException(0,
                                    "Can not find source event for relation (allready written):" + id + " Please try extending backlog.");
                        int pid = (int) line.extractInt();
                        Event pevent = events.get(pid);
                        if (pevent == EXLUDED)
                            break;
                        else if (pevent == null)
                            throw new ParseException(0, "Can not find target event for relation: " + id + " Please try extending vector.");
                        else if (pevent.isDisposed()) {
                            Relation relation = new Relation(pevent, event, label);
                            event.addRelation(relation);
                            pevent.insertRelation(relation);
                            // Utils.log(pevent.generator.stream.signal.getName(),pevent.idx, event.generator.stream.signal.getName(),event.idx);
                        } else {
                            Relation relation = new Relation(pevent, event, label);
                            event.addRelation(relation);
                            pevent.addRelation(relation);
                        }
                    }
                }
                    break;
                default:
                    throw new ParseException(0, "Unknown line");
                }

            }

            // flush remaining backlog for all streams
            for (Stream stream : streams) {
                if (stream != null) {
                    stream.write(0);
                }
            }

        } catch (ParseException e) {
            throw new ParseException(linesProcessed, e.getMessage(), e);
        } catch (Throwable e) {
            throw new ParseException(linesProcessed, e.getMessage(), e);
        } finally {

            // close
            close(current() + 1);
            lineParser.close();
        }

    }

    // ========================================================================================================================
    // Model
    // ========================================================================================================================

    /**
     * Stream represents a transaction stream in the SCV file.
     */
    class Stream {

        // Stream ID
        private int id;
        // Name of the stream
        private String name;
        // Kind of stream (e.g. input, output)
        private String kind;
        // Whether this stream is excluded by filter
        private boolean excluded;

        // Number of non-excluded generators in this stream
        private int noOfGenerators;

        // First event in the backlog
        private Event first;
        // Last event in the backlog
        private Event last;
        // Number of events in the backlog
        private int length;

        // Index for assigning event indices
        private int idxApplied = 0;
        // Index for assigning event groups
        private int groupsApplied = 0;
        // Layer assignment for events
        private int[] layersApplied = new int[ISample.LAYERS_MAX];

        // The impulse signal for this stream
        private IRecord.Signal signal;
        // Writer for structured samples
        private IStructSamplesWriter writer;

        // Index of last written event
        private int idxWritten = 0;
        // Time of last written event
        private long timeWritten = Long.MIN_VALUE;

        /**
         * Constructs a new Stream.
         * 
         * @param id
         *            Stream ID
         * @param name
         *            Stream name
         * @param kind
         *            Stream kind
         */
        public Stream(int id, String name, String kind) {

            this.id = id;
            this.name = name;
            this.kind = kind;

            // exclude
            excluded = !FilterExpression.matches(includeStreams, name, true);
            excluded |= FilterExpression.matches(excludeStreams, name, false);

            for (int n = 0; n < ISample.LAYERS_MAX; n++)
                layersApplied[n] = -1;

            // add to streams
            streams.set(id, this);
        }

        /**
         * Insert an event into the backlog, maintaining order.
         * 
         * @param event
         *            The event to insert
         * @throws ParseException
         *             If the event cannot be inserted due to backlog constraints
         */
        void insertIntoBacklog(Event event) throws ParseException {

            if (this.last != null) {
                // Insertion must preserve chronological order within backlog.
                // We walk backwards from last until the correct insertion point is found.
                Event last = this.last;
                while (last != null && last.time > event.time) {
                    // If an index has already been assigned we cannot reorder -> backlog too small
                    if (last.idx != -1)
                        throw new ParseException("Could not sort in due to assigned idx. Please increase backlog!");
                    last = last.prev;
                }
                if (last != null) {
                    // Insert after 'last' (between last and last.next)
                    event.prev = last;
                    if (last.next != null) {
                        last.next.prev = event;
                        event.next = last.next;
                    } else
                        this.last = event; // append at tail
                    last.next = event;
                } else {
                    // Insert at the very front; ensure we don't violate previously written time
                    if (event.time < timeWritten)
                        throw new ParseException("Could not sort in. Please increase backlog!");
                    event.next = this.first;
                    this.first = event;
                }

            } else {
                // first event in backlog
                this.first = this.last = event;
            }
            length++;
        }

        /**
         * Assigns index, group, and layer to the given event and all following events.
         * 
         * @param event
         *            The event to assign
         * @throws ParseException
         *             If assignment fails
         */
        void assertIdxGroupLayer(Event event) throws ParseException {

            // already applied
            if (event.idx >= 0)
                return;

            // find last event with an assigned idx to continue from there
            Event e = event;
            while (e.prev != null && e.idx == -1 && e != this.first) {
                e = e.prev;
            }
            if (e.idx >= 0) {
                // ensure consistency: the found idx should be idxApplied-1
                if (e.idx != idxApplied - 1)
                    throw new ParseException("Could not assign idx");
                e = e.next; // start applying from next
            } else if (e != this.first)
                throw new ParseException("Could not assign idx");

            // assign idx, group and layer sequentially until 'event' is reached
            while (e != null) {
                // assign consecutive index
                e.idx = idxApplied++;

                // group/layer logic:
                // - GO_INITIAL/GO_SINGLE create new group and allocate a layer (either fixed or first free)
                // - GO_FINAL reuse group and free layer slot if required
                if (e.order == ISample.GO_INITIAL || e.order == ISample.GO_SINGLE) {
                    e.group = this.groupsApplied++;
                    if (e.generator.layer >= 0)
                        e.layer = e.generator.layer;
                    else {
                        e.layer = ISample.LAYERS_MAX - 1;
                        for (int n = 0; n < ISample.LAYERS_MAX; n++)
                            if (layersApplied[n] == -1) {
                                if (e.order == ISample.GO_INITIAL)
                                    layersApplied[n] = e.id;
                                e.layer = n;
                                break;
                            }
                    }
                } else if (e.order == ISample.GO_FINAL) {
                    // final event belongs to the group of its paired initial event
                    e.group = e.groupOther != null ? e.groupOther.group : -1;
                    if (e.generator.layer < 0)
                        for (int n = 0; n < ISample.LAYERS_MAX; n++)
                            if (layersApplied[n] == e.id) {
                                layersApplied[n] = -1; // free the layer
                                break;
                            }
                }
                if (e == event)
                    break;
                e = e.next;
            }
        }

        /**
         * Ensures the signal and writer are created for this stream.
         */
        void assertSignal() {
            if (!excluded && writer == null) {

                // scope / name
                ICell scope = base;
                String name = this.name;

                // hierarchy resolution
                if (hierarchyResolution) {
                    String[] splitted = name.split("\\.");
                    for (int n = 0; n < splitted.length - 1; n++) {
                        if (scope.getChild(splitted[n]) != null)
                            scope = (RecordScope) scope.getChild(splitted[n]);
                        else {
                            RecordScope next = new RecordScope();
                            next.setName(splitted[n]);
                            scope.addChild(next);
                            scope = next;
                        }
                    }
                    name = splitted[splitted.length - 1];
                }

                // create signal
                this.signal = addSignal(scope, name, kind, ISamples.TAG_TRANSACTION, ISample.DATA_TYPE_STRUCT, -1, ISample.FORMAT_DEFAULT);
                this.writer = ((IStructSamplesWriter) getWriter(signal));
                changed(CHANGED_RECORD);
            }
        }

        /**
         * Writes events from the backlog until only 'remain' events are left.
         * 
         * @param remain
         *            Number of events to keep in the backlog
         * @throws ParseException
         *             If writing fails
         */
        public void write(int remain) throws ParseException {

            while (first != null && length > remain) {

                // write
                Event event = first;
                event.write();

                // set to next
                first = event.next;
                if (event != null)
                    event.prev = null;

                // dispose written
                event.dispose();

                length--;
            }
            if (first == null) {
                last = null;
            }
        }

        /**
         * Writes a single event to the writer.
         * 
         * @param event
         *            The event to write
         * @param attributes
         *            The attributes to write
         * @throws ParseException
         *             If writing fails
         */
        private void dowrite(Event event, StructMember[] attributes) throws ParseException {

            if (!excluded) {

                // ensure signal & writer exist and index/group/layer assigned
                assertSignal();
                assertIdxGroupLayer(event);

                // open writer for time if necessary
                if (!writer.isOpen())
                    writer.open(event.time);

                // validate sequential index ordering
                if (event.idx != idxWritten++)
                    throw new ParseException("Index mismatch");
                // allocate free layer for initial/single events
                if (event.order == ISample.GO_SINGLE || event.order == ISample.GO_INITIAL)
                    event.layer = writer.getFreeLayer();
                // write the structured sample
                if (!writer.write(event.time, false, event.order, event.layer, attributes))
                    throw new ParseException("Could not write sample into stream! :" + writer.getId());

                // record last written time and notify listeners
                timeWritten = event.time;
                changed(CHANGED_SIGNALS, timeWritten);

                // attach relations for this event if any
                if (event.relations != null)
                    for (Relation relation : event.relations) {
                        boolean reverse = relation.to == event;
                        Event target = reverse ? relation.from : relation.to;
                        if (target == null || target == EXLUDED)
                            continue;
                        long delta = target.time - event.time;
                        target.assertIdxGroupLayer();

                        // attach relation to writer; failure is fatal for consistency
                        if (!writer.attachRelation(
                                (reverse ? ISample.AT_RELATION_DELTA_POS_REV : ISample.AT_RELATION_DELTA_POS) | ISample.AT_RELATION_CONTENT_FLAG,
                                target.generator.stream.getPath(), relation.label, delta, null, ISample.CONTENT_SAMPLE, target.idx))
                            throw new ParseException("Could not attach relation into stream! " + writer.getId());
                    }
            }
        }

        /**
         * Inserts a relation for the given event.
         * 
         * @param event
         *            The event
         * @param relation
         *            The relation to insert
         * @throws ParseException
         *             If insertion fails
         */
        private void doinsert(Event event, Relation relation) throws ParseException {

            if (!excluded) {

                boolean reverse = relation.to == event;
                Event target = reverse ? relation.from : relation.to;
                if (target == null || target == EXLUDED)
                    return;
                long delta = target.time - event.time;
                target.assertIdxGroupLayer();

                if (!writer.insertRelationAt(event.idx,
                        (reverse ? ISample.AT_RELATION_DELTA_POS_REV : ISample.AT_RELATION_DELTA_POS) | ISample.AT_RELATION_CONTENT_FLAG,
                        target.generator.stream.getPath(), relation.label, delta, null, ISample.CONTENT_SAMPLE, target.idx))
                    throw new ParseException("Could not insert relation into stream! :" + writer.getId());
            }
        }

        /**
         * Gets the URI path of the signal.
         * 
         * @return The signal URI
         */
        private String getPath() {
            assertSignal();
            return signal != null ? signal.getCellUri() : "";
        }

        @Override
        public String toString() {
            return name;
        }

    }

    /**
     * Generator represents a transaction generator in the SCV file.
     */
    class Generator {

        // Generator ID
        private int id;
        // Generator name
        private String name;
        // Parent stream
        private Stream stream;
        // Whether this generator is excluded by filter
        private boolean excluded;

        // Number of fixed attributes
        private int fixedAttributes;
        // Number of begin attributes
        private int beginAttributes;
        // Number of end attributes
        private int endAttributes;
        // Number of record attributes
        private int recordAttributes;
        // Array of all attributes
        private StructMember[] attributes;
        // Map from attribute name/type pair to attribute index
        private HashMap<ScvLineParser.Pair, Integer> recordAttributeIndex = new HashMap<>();
        // Layer assignment for this generator
        private int layer = -1;

        /**
         * Constructs a new Generator.
         * 
         * @param id
         *            Generator ID
         * @param name
         *            Generator name
         * @param sid
         *            Stream ID
         */
        public Generator(int id, String name, int sid) {
            this.id = id;
            this.name = name;
            this.stream = streams.get(sid);
            generators.set(id, this);

            if (!stream.excluded) {

                // exclude
                excluded = !FilterExpression.matches(includeGenerators, name, true);
                excluded |= FilterExpression.matches(excludeGenerators, name, false);

                // fixed layer
                if (!excluded && FilterExpression.matches(generatorLayers, stream.name, false)) {
                    layer = stream.noOfGenerators;
                }

                // no of non-excluded generators
                if (!excluded)
                    stream.noOfGenerators++;
            }
        }

        /**
         * Creates a new event for this generator.
         * 
         * @param id
         *            Event ID
         * @param time
         *            Event time
         * @return The new event
         * @throws ParseException
         *             If insertion fails
         */
        public Event newEvent(int id, long time) throws ParseException {
            Event event = new Event(this, id, time);
            stream.insertIntoBacklog(event);
            return event;
        }

        /**
         * Creates a new event for this generator, based on an existing event.
         * 
         * @param event
         *            The existing event
         * @param time
         *            Event time
         * @return The new event
         * @throws ParseException
         *             If insertion fails
         */
        public Event newEvent(Event event, long time) throws ParseException {
            event = new Event(this, event, time);
            stream.insertIntoBacklog(event);
            return event;
        }

        /**
         * Gets the attribute index for a given name/type pair, creating it if necessary.
         * 
         * @param nameType
         *            The name/type pair
         * @return The attribute index, or 0 if excluded or max reached
         */
        public int getAttributeIndex(ScvLineParser.Pair nameType) {
            // lookup cached index first
            Integer idx = recordAttributeIndex.get(nameType);
            if (idx != null)
                return idx;

            // attribute not seen before - evaluate include/exclude filters
            boolean excluded = !FilterExpression.matches(includeAttributes, nameType.o1, true);
            excluded |= FilterExpression.matches(excludeAttributes, nameType.o1, false);
            if (excluded) {
                // mark as excluded with index 0 (convention used in parser)
                recordAttributeIndex.put(nameType.clone(), 0);
                return 0;
            } else {
                // compute new attribute index beyond fixed/begin/end attribute slots
                int newidx = recordAttributes + fixedAttributes + beginAttributes + endAttributes;
                if (newidx >= maxAttributes)
                    return 0; // too many attributes -> treat as excluded
                this.recordAttributes++;
                recordAttributeIndex.put(nameType.clone(), newidx);
                this.attributes[newidx] = new StructMember(-1, null, nameType.o1, null, null, null, structType(nameType.o1, nameType.o2), -1,
                        format(nameType.o1, nameType.o2), null);
                return newidx;
            }
        }

        /**
         * Initializes the generator's attributes from begin and end lists.
         * 
         * @param begin
         *            List of begin attributes
         * @param end
         *            List of end attributes
         */
        public void init(List<StructMember> begin, List<StructMember> end) {
            this.attributes = new StructMember[maxAttributes];

            this.fixedAttributes = 2;
            this.attributes[0] = new StructMember(-1, null, "scvId", null, null, null,
                    StructMember.DATA_TYPE_INTEGER | StructMember.STRUCT_MOD_HIDDEN, -1, ISample.FORMAT_DEFAULT, null);
            this.attributes[1] = new StructMember(-1, null, "scvGenerator", null, null, null, StructMember.DATA_TYPE_ENUM, -1, ISample.FORMAT_LABEL,
                    name);

            this.beginAttributes = begin.size();
            System.arraycopy(begin.toArray(new StructMember[begin.size()]), 0, this.attributes, fixedAttributes, beginAttributes);
            this.endAttributes = end.size();
            System.arraycopy(end.toArray(new StructMember[end.size()]), 0, this.attributes, fixedAttributes + beginAttributes, endAttributes);
        }

        /**
         * Writes an event for this generator.
         * 
         * @param event
         *            The event to write
         * @throws ParseException
         *             If writing fails
         */
        private void dowrite(Event event) throws ParseException {

            if (!isExcluded()) {

                // id
                this.attributes[0].setValue(event.id);

                // attributes
                for (int n = fixedAttributes; n < maxAttributes; n++) {
                    if (this.attributes[n] == null)
                        break;
                    Object value = event.attributes[n];
                    if (value != null) {
                        this.attributes[n].setValue(value);
                        this.attributes[n].setValid(true);
                    } else
                        this.attributes[n].setValid(false);
                }

                stream.dowrite(event, attributes);
            }
        }
        // additional.add(new StructMember(name, structType(type)/* | StructMember.STRUCT_MOD_HIDDEN */, null, format(type),
        // value(structType(type), value)));

        /**
         * Returns whether this generator or its stream is excluded.
         * 
         * @return true if excluded
         */
        public boolean isExcluded() {
            return excluded || stream.excluded;
        }

        @Override
        public String toString() {
            return stream + "/" + name;
        }
    }

    /**
     * Event represents a transaction event in the SCV file.
     */
    class Event {
        // Parent generator
        Generator generator;
        // Event ID
        int id;
        // Event order (GO_INITIAL, GO_FINAL, etc)
        int order;
        // Event time
        long time;
        // Next event in backlog
        Event next;
        // Previous event in backlog
        Event prev;
        // Paired event for group assignment
        Event groupOther;
        // Attribute position for this event
        int attributePos;
        // Attribute values for this event
        Object[] attributes;
        // Relations for this event
        List<Relation> relations;

        // Event index
        int idx;
        // Event group
        int group;
        // Event layer
        int layer;

        /**
         * Constructs an event with only an ID (used for EXLUDED).
         * 
         * @param id
         *            Event ID
         */
        public Event(int id) {
            this.id = id;
        }

        /**
         * Constructs a new event.
         * 
         * @param generator
         *            Parent generator
         * @param id
         *            Event ID
         * @param time
         *            Event time
         * @param group
         *            Group index
         * @param order
         *            Event order
         */
        protected Event(Generator generator, int id, long time, int group, int order) {
            this.generator = generator;
            this.id = id;
            this.time = time;
            this.group = group;
            this.order = order;
            this.attributePos = order == ISample.GO_INITIAL ? generator.fixedAttributes : generator.fixedAttributes + generator.beginAttributes;
            this.idx = -1;
            this.attributes = new Object[maxAttributes];
        }

        /**
         * Constructs a new initial event.
         * 
         * @param generator
         *            Parent generator
         * @param id
         *            Event ID
         * @param time
         *            Event time
         */
        public Event(Generator generator, int id, long time) {
            this(generator, id, time, -1, ISample.GO_INITIAL);

        }

        /**
         * Constructs a new final event based on an existing event.
         * 
         * @param generator
         *            Parent generator
         * @param event
         *            Existing event
         * @param time
         *            Event time
         */
        public Event(Generator generator, Event event, long time) {
            this(generator, event.id, time, -1, ISample.GO_FINAL);
            event.groupOther = this;
            this.groupOther = event;
        }

        /**
         * Constructs a new final event with group.
         * 
         * @param generator
         *            Parent generator
         * @param id
         *            Event ID
         * @param group
         *            Group index
         * @param time
         *            Event time
         */
        public Event(Generator generator, int id, int group, long time) {
            this(generator, id, time, group, ISample.GO_FINAL);
        }

        /**
         * Disposes this event, clearing references and attributes.
         * 
         * @throws ParseException
         *             If an error occurs
         */
        public void dispose() throws ParseException {

            prev = next = null;
            if (relations != null)
                relations.clear();
            relations = null;
            attributes = null;
        }

        /**
         * Returns whether this event is disposed.
         * 
         * @return true if disposed
         */
        public boolean isDisposed() {

            return attributes == null;
        }

        /**
         * Adds a relation to this event.
         * 
         * @param relation
         *            The relation to add
         */
        public void addRelation(Relation relation) {
            if (this.relations == null)
                this.relations = new ArrayList<>();
            this.relations.add(relation);
        }

        /**
         * Inserts a relation for this event.
         * 
         * @param relation
         *            The relation to insert
         * @throws ParseException
         *             If insertion fails
         */
        public void insertRelation(Relation relation) throws ParseException {
            if (generator != null)
                generator.stream.doinsert(this, relation);
        }

        /**
         * Converts this event to a single event (GO_SINGLE).
         */
        public void toSingle() {
            if (order == ISample.GO_INITIAL) {
                order = ISample.GO_SINGLE;
                attributePos = generator.fixedAttributes + generator.beginAttributes;
            }

        }

        /**
         * Writes this event using its generator.
         * 
         * @throws ParseException
         *             If writing fails
         */
        public void write() throws ParseException {
            generator.dowrite(this);

        }

        /**
         * Ensures index, group, and layer are assigned for this event.
         * 
         * @throws ParseException
         *             If assignment fails
         */
        public void assertIdxGroupLayer() throws ParseException {

            if (idx < 0)
                generator.stream.assertIdxGroupLayer(this);
        }

        @Override
        public String toString() {
            return generator + " " + id;
        }
    }

    /**
     * Relation represents a relation between two events.
     */
    class Relation {
        // Source event
        Event from;
        // Target event
        Event to;
        // Relation label
        String label;

        /**
         * Constructs a new relation.
         * 
         * @param from
         *            Source event
         * @param to
         *            Target event
         * @param label
         *            Relation label
         */
        public Relation(Event from, Event to, String label) {
            super();
            this.from = from;
            this.to = to;
            this.label = label.replace("/", "_");
        }
    }

    /**
     * EventVector is a circular buffer for storing events by ID.
     */
    class EventVector {

        // Array of events
        Event[] events;
        // Buffer size
        int size;
        // Maximum event ID seen
        int max = 0;

        /**
         * Constructs a new EventVector.
         * 
         * @param size
         *            Buffer size
         */
        EventVector(int size) {
            this.size = size;
            this.events = new Event[size];
        }

        /**
         * Sets an event in the buffer.
         * 
         * @param event
         *            The event to set
         */
        void set(Event event) {
            final int id = event.id;
            if (event.id >= 0) {
                if (id > max)
                    max = id;
                final int index = id % size;
                events[index] = event;
            }
        }

        /**
         * Marks an event ID as excluded.
         * 
         * @param id
         *            Event ID
         */
        void exclude(int id) {
            // Mark the slot as excluded sentinel for given id to avoid later lookups creating events
            if (id >= 0) {
                if (id > max)
                    max = id;
                final int index = id % size;
                events[index] = EXLUDED;
            }
        }

        /**
         * Gets an event by ID.
         * 
         * @param id
         *            Event ID
         * @return The event, or null if not found
         */
        Event get(int id) {
            if (id >= 0 && id > max - size && id <= max) {
                final int index = id % size;
                Event event = events[index];
                if (event != null && (event.id == id || event == EXLUDED))
                    return event;
            }
            return null;
        }
    }
    // ========================================================================================================================
    // Helper
    // ========================================================================================================================

    /**
     * Determines the struct type for a given attribute name and type.
     * 
     * @param name
     *            The attribute name
     * @param type
     *            The attribute type string
     * @return The struct type constant
     */
    int structType(String name, String type) {
        if (FilterExpression.matches(useText, name, false))
            return StructMember.DATA_TYPE_TEXT;
        else if ("UNSIGNED".equals(type))
            return StructMember.DATA_TYPE_INTEGER;
        else if ("INTEGER".equals(type))
            return StructMember.DATA_TYPE_INTEGER;
        else if ("ENUMERATION".equals(type))
            return StructMember.DATA_TYPE_ENUM;
        else if ("POINTER".equals(type))
            return StructMember.DATA_TYPE_INTEGER;
        else if ("BOOLEAN".equals(type))
            return StructMember.DATA_TYPE_INTEGER;
        else if ("FLOATING_POINT_NUMBER".equals(type))
            return StructMember.DATA_TYPE_FLOAT;
        else if ("STRING".equals(type))
            return StructMember.DATA_TYPE_ENUM;
        return StructMember.DATA_TYPE_TEXT;
    }

    /**
     * Determines the format string for a given attribute name and type.
     * 
     * @param name
     *            The attribute name
     * @param type
     *            The attribute type string
     * @return The format string
     */
    String format(String name, String type) {
        if (FilterExpression.matches(useText, type, false))
            return ISample.FORMAT_DEFAULT;
        else if ("UNSIGEND".equals(type))
            return ISample.FORMAT_DECIMAL;
        else if ("INTEGER".equals(type))
            return ISample.FORMAT_DECIMAL;
        else if ("ENUMERATION".equals(type))
            return ISample.FORMAT_LABEL;
        else if ("POINTER".equals(type))
            return ISample.FORMAT_HEXADECIMAL;
        else if ("BOOLEAN".equals(type))
            return ISample.FORMAT_BOOLEAN;
        else if ("FLOATING_POINT_NUMBER".equals(type))
            return ISample.FORMAT_DECIMAL;

        return ISample.FORMAT_DEFAULT;
    }

    /**
     * ScvLineParser parses lines from the SCV file.
     */
    final class ScvLineParser extends FastLineParser {

        // Temporary pair instance for parsing
        private Pair pair = new Pair(null, null);

        /**
         * Pair represents a name/type pair for attributes.
         */
        public class Pair implements Cloneable {

            // First value (name)
            public String o1;
            // Second value (type)
            public String o2;

            /**
             * Constructs a new Pair.
             * 
             * @param o1
             *            First value
             * @param o2
             *            Second value
             */
            public Pair(String o1, String o2) {
                super();
                this.o1 = o1;
                this.o2 = o2;
            }

            @Override
            public int hashCode() {
                int hash = 7;
                hash = 31 * hash + (o1 != null ? o1.hashCode() : 0);
                hash = 31 * hash + (o2 != null ? o2.hashCode() : 0);
                return hash;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o)
                    return true;
                if (o instanceof Pair) {
                    Pair pair = (Pair) o;
                    if (o1 != null ? !o1.equals(pair.o1) : pair.o1 != null)
                        return false;
                    if (o2 != null ? !o2.equals(pair.o2) : pair.o2 != null)
                        return false;
                    return true;
                }
                return false;
            }

            /**
             * Clones this pair.
             * 
             * @return A new Pair with the same values
             */
            public Pair clone() {
                try {
                    return (Pair) super.clone();
                } catch (CloneNotSupportedException e) {
                }
                return null;
            }
        }

        /**
         * Constructs a new ScvLineParser.
         * 
         * @param in
         *            Input stream
         */
        public ScvLineParser(InputStream in/* , Charset charset */) {
            super(in/* ,charset */);
        }

        /**
         * Extracts a TimeBase unit from the current token.
         * 
         * @return The parsed TimeBase
         * @throws ParseException
         *             If parsing fails
         */
        public TimeBase extractUnit() throws ParseException {
            String s = extractToken();
            return TimeBase.parse(s);
        }

        /**
         * Extracts a name/type pair from the current line.
         * 
         * @return The parsed Pair
         * @throws ParseException
         *             If parsing fails
         */
        public Pair extractNameTypePair() throws ParseException {
            final Pair pair = this.pair;
            // parse attribute name then its declared type (token or identifier)
            pair.o1 = extractStringifiedToken();
            pair.o2 = extractToken();
            return pair;
        }

        /**
         * Extracts a value for the given struct member.
         * 
         * @param member
         *            The struct member
         * @return The parsed value
         * @throws ParseException
         *             If parsing fails
         */
        public Object extractValue(StructMember member) throws ParseException {
            // determine extraction method according to struct member main type and format
            if (member != null) {
                int type = member.getMainType();
                String format = member.getFormat();
                if (type == StructMember.DATA_TYPE_INTEGER && !Utils.equals(format, ISample.FORMAT_BOOLEAN))
                    return extractLong(); // integer numeric
                else if (type == StructMember.DATA_TYPE_INTEGER && Utils.equals(format, ISample.FORMAT_BOOLEAN))
                    return extractBoolean() ? 1 : 0; // boolean represented as integer
                else if (type == StructMember.DATA_TYPE_FLOAT)
                    return extractDouble(); // floating point
                else if (type == StructMember.DATA_TYPE_ENUM)
                    return extractStringifiedToken(true); // enumerations use tokenized strings
                else {
                    // default: treat as text block (may be quoted or multi-token)
                    return extractStringifiedText(true);
                }
            }
            return null;
        }

    }
}
